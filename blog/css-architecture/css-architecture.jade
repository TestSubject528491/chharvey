doctype html
html(lang="en" xmlns="http://www.w3.org/1999/xhtml")
  head
    title CSS Architecture
    meta(charset="utf-8")
    meta(name="author" content="Christopher H. Harvey")
    meta(name="description" content="Write good CSS.")
    meta(name="keywords" content="css, code organization, code architecture")
    meta(name="viewport" content="width=device-width, initial-scale=1")
    link(rel="stylesheet" href="../../styles/chharvey.css")
  body.o-GoldenContainer
    p(style="position:fixed;font-weight:bold;font-size:1.5rem;color:red;") WARNING: THIS DRAFT IS INCOMPLETE AND POSSIBLY EVEN INCORRECT. DO NOT CITE OR REFERENCE IT. IT WILL BE MERGED INTO ANOTHER DOCUMENT AND RELEASED AT A LATER TIME.
    main.o-GoldenContainer__Content.c-Document.c-Document--draft(data-status="draft" itemscope="" itemtype="https://schema.org/Article")
      header
        h1(itemprop="name headline") CSS Architecture
        p.o-GoldenContainer__Content__SideMinor.o-Box.o-Box--island.c-Alert.c-Alert--dang.
          This document is a work in progress.
        dl.c-Document__Meta
          dt Author
          dd(itemprop="author") Christopher H. Harvey
          dt Description
          dd(itemprop="description").
            A discussion on writing and organizing
            good, scalable, maintainable, powerful, efficient
            #[abbr.c-Acro(title="Cascading Stylesheets") CSS] code.
          dt Keywords
          dd(itemprop="keywords") #[abbr(title="Cascading StyleSheets") CSS]
          dd(itemprop="keywords") #[abbr(title="HyperText Markup Languge") HTML]
          dd(itemprop="keywords") code organization, architecture
          dt Version History
          dd.update
            time(datetime="2015-03-27") Mar 27, 2015
          dd.update
            time(datetime="2015-04-09 17:54") Apr 8, 2015 #[span.tod 5:54 PM]
          dd.update
            time(datetime="2015-04-13 14:30") Apr 13, 2015 #[span.tod 2:30 PM]
          dd.update
            time(datetime="2015-10-03 12:13") Oct 3, 2015 #[span.tod 12:13 PM]
          dd.update
            time(datetime="2016-02-03 17:47") Feb 3, 2016 #[span.tod 5:47 PM]
          dd.update(itemprop="dateModified")
            time(datetime="2016-02-03 23:14") Feb 3, 2016 #[span.tod 11:14 PM]
            small.o-Textbox.c-Label.c-Label--dang(class="!ml:1") Latest
      section
        h2 Introduction
        p.c-Lede.c-Lede--dropcap.
          This document is a compilation of what I have learned about writing
          good, scalable, maintainable, powerful, efficient
          #[abbr.c-Acro(title="Cascading Stylesheets") CSS] code.
        p.c-Lede.
          First we start off from a narrow approach, looking at the CSS language itself,
          and then we work our way larger, discussing the ways it interacts with itself and
          with HTML.
        //- p Define properties, selectors, and stylesheets in order of increasing specificity.
        p.c-Lede.
          Note that this is not a coding style guide. How you format your code is up to your or your
          organization&rsquo;s style guide. Here we look at code from a higher level
          point of view.
      section#grouping-css-properties
        h2 Grouping CSS Properties
        p.
          A CSS ruleset contains one or more property-value pairs. Within this ruleset,
          properties should be grouped by function, and these groups should be
          ordered in #[strong decreasing structure definition].
        p.
          There are two reasons for this. First, code hand-typed in this manner is
          much easier to communicate, maintain, and visualize. For example, you&rsquo;d like
          to know what a class looks like just by its code, not having to test it in the browser.
          Having an arbitrary order (such as alphabetical) makes it harder to visualize it.
        p: small.
          One of the arguments for alphabetical ordering is that it makes maintenance
          easier. That would be true, if selectors normally had a ton of rules
          in their rulesets. But we&rsquo;ll see later on that this is rarely,
          if ever, the case. If you keep your rulesets to a minimum of, say,
          five rules, then alphabetical ordering is basically useless.
        p.
          There is another reason to group properties by function, as well.
          CSS classes can be split into designated responsibilities, that is, authors may use
          separate classes for layout #[i(lang="la"): abbr(title="versus") vs.]
          structure #[i(lang="la"): abbr(title="versus") vs.] text properties.
          This makes the CSS
          more modular and reusable, and we will see how that is done in the next section.
        p.
          Also keep in mind that this order applies to properties #[em within a ruleset].
          We&rsquo;ll talk later about ordering rulesets within a stylesheet&mdash;and
          then later, ordering stylesheets themselves.
        figure
          img(style="box-shadow: none;" src="../images/css-pyramid-props.svg" alt="An inverted pyramid illustrates how CSS properties are related. The top contains layout and structure, the middle contains typography, and the bottom contains cosmetics.")
          figcaption.c-Caption.c-Caption--after.
            This inverted triangle illustrates how CSS properties are related.
            From top to bottom, structural definition is exchanged for cosmetic styling.
        ol
          li: p.
            #[strong Layout.]
            The top base of the pyramid contains properties that set up foundation and layout,
            such as display and position. These properties most define the element&rsquo;s
            relationship with others on the page.
          li: p.
            #[strong Box Structure.]
            The next level is similar, but with more of an inner focus, setting up box structure
            like width, padding, and margin. Transformations are also included in this level.
          li: p.
            #[strong Text Structure.]
            The middle level contains typographical structure: font, text alignment and spacing,
            etc. Anything that describes the composition of text goes here.
          li: p.
            #[strong Box Cosmetics.]
            This level sets the look-and-feel of the box model of elements.
            These properties only change the cosmetics, not the structure of the box.
            The styles of the box are set before the styles of the text inside.
          li: p.
            #[strong Text Cosmetics.]
            This level sets the decorative style of the text, again, unrelated
            to its structure.
            Notice how we work from outer to inner, styling the
            cosmetics of the container before its contents.
          li: p.
            #[strong Other.]
            The last level, at the vertex, is for miscellaneous properties.
            These properties don&rsquo;t belong in any particular category.
        figure
          figcaption.c-Caption.c-Caption--before.
            An outline listing the most common CSS properties in each category.
            #[strong Note this is not a complete list of all CSS properties.]
            If a property is not listed, use your best judgement for its place.
          ol(class="a-ff-accent a-fzb-milli")
            li Layout:
              ol
                li display
                li position, top, left, bottom, right
                li float, clear
                li z-index
                li vertical-align
                li flex-direction, flex-wrap, justify-content, align-content, align-items, flex, order
            li Box Structure:
              ol
                li box-sizing
                li width, height
                li padding, margin
                li transformations
            li Text Structure:
              ol
                li font[-style|-variant|-weight|-size|-family]? #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li line-height                                  #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li letter-spacing                               #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li word-spacing                                 #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li text-align                                   #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li text-indent                                  #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li white-space                                  #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li overflow-wrap (word-wrap)                    #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li column[-count|-width|s]
                li page-break-[before|after]
            li Box Cosmetics:
              ol
                li border[-width|-style|-color|-radius]?
                li outline
                li box-shadow
                li background[-image|-position|-size|-repeat|-attachment|-origin|-clip|-color]?
                li overflow
                li opacity
                li visibility                          #[small.o-Textbox.c-Label.c-Label--skss inherited]
            li Text Cosmetics:
              ol
                li text-rendering                      #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li text-transform                      #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li text-decoration
                li text-shadow                         #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li text-overflow
                li list-style[-type|-position|-image]? #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li quotes
                li color                               #[small.o-Textbox.c-Label.c-Label--skss inherited]
            li Other:
              ol
                li cursor                              #[small.o-Textbox.c-Label.c-Label--skss inherited]
                li transition
      aside.o-GoldenContainer__Content__SideMajor.c-Document__Draft#semantics-trumps-style
        h2 Semantics Trumps Style
        p.
          When it comes down to efficient HTML
          versus efficient CSS, HTML wins. The reason? Semantics trumps style.
          This happens on two fronts. First simply for the sake of principle. The most
          important data is the actual content being presented. This trumps any data on
          #[em how] it is being presented. If you have to sacrifice one for the other,
          content trumps presentation.
          While that seems fine as a theoretical argument, there is also evidence to back it up.
        p.
          The second front on which semantics trumps style is seen from a more practical
          point of view. For example, every design change should, at
          least mostly, be taken care of in the CSS.
          You&rsquo;ve got a problem when you find yourself having to adjust a massive
          number of #[code class] attributes to implement a design change (ahem, looking at you, Atomic CSS).
          Or wrapping content with unsemantic #[code div] elements just to make it look right.
          It should be the other way around: when the design changes, you should
          be&mdash;mostly&mdash;adjusting your CSS. It is the CSS that should conform to
          how HTML is written, even if it means sacrificing a little bit of efficiency.
        p.
          One of the arguments against this is, #[q well, the bloat&rsquo;s gotta be somewhere.]
          But the trade-off can be seen on the user end. Which is worse, HTML bloat
          or CSS bloat? Every time the user loads a new page, all that markup is downloaded,
          every time, whereas hopefully your stylesheet will have been downloaded only once
          and then cached.
      section#classes-of-classes
        h2 #[i Classes] of Classes
        p.
          In the last section, we talked about CSS properties, a relatively lower level aspect
          of CSS architecture. You might have noticed however that I&rsquo;ve already hinted at
          something slightly more involved, and that is it can be good practice to literally
          group related properties, not within a css selector, but into separate selectors.
        p.
          Here we look at the many, #[em many] uses of the HTML #[code class] attribute,
          categorize them, and talk about the different types of CSS classes
          we can create based on the properties they contain.
        p.
          For the sake of simplicity, we will not be discussing the actual naming
          of CSS classes in this section, so I will refrain from using them.
          Instead, I will use variables like #[code: var classname].
        section
          h3(class="!fs:i !fv:i !fw:i")
            b class&middot;i&middot;tis
            |  (kl&aelig;s-a&#x026a;&apos;t&#x0258;s) 
            abbr(class="!fs:t" title="noun") n.
          p.
            No, I&rsquo;m not talking about an overuse of classes&mdash;I don&rsquo;t
            believe you can ever use too many classes in HTML. #[b Classitis] in my
            opinion refers to the fact that we are using HTML classes for #[em everything],
            and this becomes overwhelming when it comes to architecting and maintaining CSS.
            We need to seriously analyze the different ways in which we are using classes,
            separate and organize them into #[i classifications] to clearly identify each use,
            and maybe provide some alternative methods and/or conventions for implementing
            semantics and style.
          //- p.
            I even go insofar as to suggest ammendments to the CSS specification. After all,
            #[a we are using a very old technology to achieve very new things].
          p But first, some background information.
        section.c-Document__Draft
          h3 Background
          p.
            #[strong The original intent of HTML classes.]
            The HTML #[code class] attribute was #[a originally] meant to group
            semantically similar elements together. For example, all elements that
            represent warnings on a page could all have #[code [class="warning"]].
            A side effect of semantically similar elements belonging to one class
            is that they can all be styled the same way with the CSS #[code .warning] class.
            Well, it seems now we have blown this way out of proportion.
          p.
            With the development of #[a Object-Oriented CSS], we have learned to take advantage of
            classes and use them for many different reasons. This can be a good thing or a bad thing.
            On one hand, authors are successfully implementing best practices: separating concerns,
            abstracting reusable components, maximizing performance,
            #[i(lang="la"): abbr(title="et cetera") etc.] On the other hand,
            such a diverse use of one specific feature of HTML has grown so large it has become an epidemic.
          p.
            Now, instead of using CSS classes to merely group similar elements together, we are using them
            to define patterns of style repeated throughout a page or site,
            and then making elements #[i instantiate] them, if you will.
            While syntactically, there really is no change, there&rsquo;s something fundamentally,
            subtly, different going on here. Instead of saying,
            #[q these two Elements are similar in meaning; I should give them the same class so that they appear the same],
            we&rsquo;re now saying,
            #[q I want these two Elements to appear the same (for whatever reason); I should give them the same class].
            It&rsquo;s almost backwards!
          p.
            I&rsquo;m not here to tell you not to use classes. In fact I think classes are the perfect
            mechanism for this. But as you read this article I do hope you become more aware of the
            different types of classes you are using, and you are able to make smart decisions about
            when you should or should not be using them.
      section
        h2 Stylesheet Order
        p.
          The previous section discussed organizing CSS at a lower level: organizing properties
          within any given selector or grouping properties into separate selectors by responsibility.
          This section discusses CSS at a higher level: different types of stylesheets and the order
          in which to load them into your project.
        section
          h3 Key Metrics
          p.
            There are 3 metrics on which to base your organization of your stylesheets.
            This section is a more abstract discussion. See the next section for a tangible examples.
          ul
            li Generic &rarr; Explicit
            li Far-Reaching &rarr; Localized
            li Low Specificity &rarr; High Specificity
          section
            h4 Discussion
            p.
              What might not be apparent is that there may be some cases in which
              moving from one end to the other end of one spectrum might correspond
              to moving in the #[em opposite] direction on another spectrum. That is,
              some selectors that are more explicit than others may not always be
              more localized or have a higher specificity. It&rsquo;s important
              to understand, though, that your selectors should be put in order that
              #[em on average] corresponds to moving from the left to right in the
              metrics discussed above.
        section
          h3 Categories of Stylesheets
          p.
            Stylesheets should be imported in order from most generic to least generic.
            It is recommended to split stylesheets into the following categories.
          ol
            li global project settings (#[code @import]s, frameworks, site-wide number and color constants)
            li helper tools (math functions, mixins for vendor-specific css, fallbacks)
            li unclassed base elements
            li objects (structural patterns, layout, containers, etc.)
            li components (specific pieces of UI with look-and-feel)
            li utilities (trumps, hacks, states, anomalies, special cases, #[code !important], etc.)
          img(src="../images/css-pyramid-sheets.svg" alt="An inverted pyramid illustrates how CSS stylesheets should be implemented.")
          section
            h4 Settings
            p.
              The Settings stylesheet contains all the variables, functions, and constants that
              you want accessible throughout the entire project. Since it&rsquo;s imported first,
              every subsequent stylesheet has access to it.
            p.
              This stylesheet is where you #[code @import] any other frameworks (normalize, resets, etc.).
              Imports should be at the top.
            p.
              After imports, include global site-wide constants such as main font size, line-height,
              font families, colors, and spacing constants that give the site its look and feel.
              They may be changed here.
          section
            h4 Tools
            p.
              Tools are used only for encapsulating repetitive tasks. They should not be accessible
              to HTML elements (thus they should be mixins, not classes), but they may be used in
              subsequent stylesheets. There are 3 types of tools.
            section
              h5 Math Functions
              p.
                Math functions make doing mathematical operations easier. For example you may want
                to define a function that averages two numbers evenly, or that adds a transparent
                factor (alpha) to an rgb color. These functions are content-ambiguous by nature,
                and do not produce actual CSS properties. They only take input values and produce
                output values.
            section
              h5 Fallback Tools
              p.
                Fallback tools are exactly that. They are mixins that you want to use to
                encapsulate fallback rules or vendor-specific rules. These mixins #[em do] produce
                actual CSS, but only if they&rsquo;re included in a CSS selector. Displaying a
                flexbox, for example, needs to support multiple browsers and/or a fallback for
                browsers not supporting it. Rather than repeating the same handful of rules over
                and over again, use a tool that will automate this task.
            section
              h5 Modules
              p.
                Modules are small tools that make your life easier. Like fallback tools, modules
                combine multiple properties to achieve an effect, except that these properties
                aren&rsquo;t all variations of the same thing. They are actually different
                properties that when combined take care of one task. One example is the
                #[code .font-size-block()] tool.
              pre.
                .font-size-block(@ratio) {
                  font-size: (@ratio * 1rem);
                  line-height: (@project_line_height / @ratio);
                  // @project_line_height is a global variable defined in the Settings sheet
                }
              p.
                This mixin sets the font size of a block and adjusts its line height such that
                the total height of the block will be an integer multiple of the project line height.
                This is a common Tool used to maintain vertical rhythm.
              p.
                Other similar examples include a module that adds a bottom border to an Element but
                removes an equivalent amount of bottom margin, or a brand font module that requires
                #[code font-weight: bold;] every time a certain font family is set.
              p.
                Modules can also be thought of as pieces of #[a(rel="this" href="#objects") Objects]
                and #[a(rel="this" href="#components") Components], or #[i Legos] that are used
                repetitively throughout the project. They utilize reusable and abstract design patterns,
                but do not describe whole Objects or Components. More examples include a type of border
                used as a particular theme, or a particular amount of padding on a box.
              p.
                Again, modules should not be accessible to HTML Elements. They should be mixins that
                you include in your Less selectors. If a certain Object needs to use a module (or any Tool),
                include it in that Object&rsquo;s class definition.
          section
            h4 Base
            p.
              The Base stylesheet is the first stylesheet with real selectors. This is what shows up
              first in the compiled output CSS. All its selectors are unclassed HTML Elements.
              Think of it as a tailored normalize stylesheet for your project typography. If your
              project Settings sheet imports other frameworks, this stylesheet will build on top of
              those frameworks. This stylesheet is very broad and general, because it comes early
              in the cascade and is likely to be overridden later.
          section
            h4 Objects
          section
            h4 Components
            aside
              p.
                Objects and Components are actual CSS classes that can be applied to
                HTML Elements. In OOP-speak, Objects and Components are classes that Elements can
                #[i instantiate]. Tools, on the other hand, should not be accessible to HTML Elements,
                only to CSS classes. Tools are more analogous to interfaces instead of classes.
                Elements cannot instantiate interfaces but classes can implement them.
              p.
                An Object or a Component itself may not be one semantic Element; it may be a grouping
                of semantic Elements. For example it may contain an image, heading,
                and paragraph. The Object/Component as a whole though is simply a #[code div].
          section
            h4 Utilities
            p.
      footer
        h1 References
        p Based off of #[a(rel="external" href="http://itcss.io/") Harry Roberts&rsquo;s Theory of ITCSS].
