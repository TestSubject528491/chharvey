doctype html
html(lang="en" xmlns="http://www.w3.org/1999/xhtml")
  body.o-GoldenContainer
    p(style="position:fixed;font-weight:bold;font-size:1.5rem;color:red;") WARNING: THIS DRAFT IS INCOMPLETE AND POSSIBLY EVEN INCORRECT. DO NOT CITE OR REFERENCE IT. IT WILL BE MERGED INTO ANOTHER DOCUMENT AND RELEASED AT A LATER TIME.
    main.o-GoldenContainer__Content.c-Document(data-status="draft" itemscope="" itemtype="http://schema.org/Article")
      section
        h2 Introduction
        p.
      section
        section
          h3 Components
        section
          h3 Subclasses of Objects &amp; Components
          p.
            As in an OO programming language, a subclasses extends a class by specifying parameters
            that were previously open, or overriding previously-defined parameters. A subclass of an
            Object (or Component) is a special case of that Object (or Component): it&rsquo;s the same
            thing but maybe just with a few small changes. Defining a subclass on an Object is
            beneficial to defining a whole new Object because it saves you from repeating code.
        section
          h3 Utilities
          p.
            Overrides, helper classes, hacks, and things that use #[code !important].
          section
            h4 Type 1 Utility: Atoms. Classnames that describe their definitions
            p.
              Because of the rigid static nature of these classes, the classnames are
              allowed to be descriptive, that is, they describe their contents.
              The atom #[code .mt1 {margin-top: 1rem !important;}] is a good example. Its name
              reflects its style definition, which is okay because we aren't expecting either to change.
              If however we did change it from `1rem` to `2rem` then `.mt1` would be a silly name for
              the class, wouldn't it?
            section
              h4 A discussion on Atoms
            p.
              Now you might be wondering what the advantage of Atoms are over inline styles.
              First, they&rsquo;re less specific. Even with #[code !important], they&rsquo;re
              easier to override than an inline style. (But I&rsquo;m not sure why you would ever
              want to override an Atom in the first place when you could simply remove it.)
            p.
              Atomic CSS is a very radical ideology that basically says your entire codebase should
              consist of nothing but atoms, and then you would use only those atoms in HTML
              to style a site. I won't go into much detail but I will say that without a templating
              system this will hinder development a lot. Personally, I don't see a difference between
              defining templates to have certain classes versus defining classes to have certain
              properties. It's just one more step to add to workflow.
              defining a template so that a "button" component will have classes
              background-gradient-blue  on-hover-background-lighten  border-outset
              on-click-border-inset  border-rounded-corners-10
              This results in very bloated markup, with site components needing tons of classes.
            pre.
              &lt;a class="background-gradient-blue  on-hover-background-lighten  border-outset
                        on-click-border-inset  border-rounded-corners-10  etc  etc  etc"&gt;press me&lt;/a&gt;
            p.
               very much .The argument for this 
            p.
              Read about *Atomic CSS* [here](https://www.lucidchart.com/techblog/2014/01/31/atomic-css-tool-set/) and  [here](http://www.smashingmagazine.com/2013/10/21/challenging-css-best-practices-atomic-approach/) for more examples. It shouldn't be very hard to guess how these classes are defined.
            p.
              These classnames describe the properties that define the class. Examples include
              `.big` and `.margin-top-24`. Read about *Atomic CSS*
              [here](https://www.lucidchart.com/techblog/2014/01/31/atomic-css-tool-set/) and
              [here](http://www.smashingmagazine.com/2013/10/21/challenging-css-best-practices-atomic-approach/)
              for more examples. It shouldn't be very hard to guess how these classes are defined.
          section
            h4 Type 2 Utility: Classnames that describe their general appearance
            p.
              While truly presentational classes describe the properties in their definitions, there
              is a bit of a step up in types of presentational classes. Classes that describe their
              *general* appearance are still presentational, but are not so specifically named that
              their properties are locked.
            p.
              Take `.grid-50-left` for example. The name of the class indicates the look of the
              component, namely, that it should be 50% wide and moved to the left, but it does not
              explicitly say *how* it achieves this look. It may use floats, a table-like layout,
              flex boxes, or grid layouts. The implementation of its appearance may be changed, so
              long as its appearance stays the same. Another example would be `.list-inline`.
            pre.
              ### Discussion: Type 1 and Type 2

              There are some cases in which having presentational classes available in CSS is helpful.
              In short, they provide abstraction. Type 1 and Type 2 classes can be used as a mechanism
              for site-wide consistency, and can save developers the hassle of having to repeat the
              same lines of code over and over again. For example, redefining the same top margin on
              multiple elements is not only tedious but also error prone. The developer has to remember
              the number of pixels, code is repeated, and upkeep is expensive. These classes provide
              an easy and scalable solution. Another case of this is using a grid system. A class such
              as `.grid-50-left` is *very* presentational but necessary for DRY code.

              Though presentational classes are useful to CSS developers, Type 1 and Type 2 should
              *not* be accessible to the HTML. There are a number of reasons why:

              - HTML describes content, not presentation. Technically, classes are in the HTML.
              It is an HTML attribute, and thus adding a value to the `class` attribute of an element
              should have *some* semantic meaning (even if only for humans). The classname `.boldred`
              for example does not add any semantic value to the HTML. An ideal alternative would be
                to use `.warning` (or something similar) and then have the `.warning` class use the
                properties defined in `.boldred` in some way. More on that later. `.warning` would
                go in the [Type 3 category](#type-3).
              - **The Theoretical Redesign Future.** If you wanted to change the properties of the
              `.boldred` class, say, make it italic instead of bold, now you have to deal with an
              awkward classname, or you have to change the classname from `class="boldred"` to
              `class="italicred"` everywhere in the HTML. Sure, a search-and-replace tool would be
              useful, but you shouldn't have to put yourself through all that trouble. On the other
              hand, you are free to change `font-weight: bold;` to `font-style: italic;` in the
              definition of `.warning` easily without dealing with a classname that doesn't match
              its definition.

              The point is not to say that `.boldred` *shouldn't* be a classname. It very well can be!
              In fact, if a lot of elements use the properties of this class, you *should* make
              `.boldred` a class, so you can use it as a tool to abstract a repeating pattern. The
              point *is*, however, to say that this class should *not* be available to HTML elements.
              [Continue reading for a discussion on how to do this.]

              Type 2 classes are *a bit* of a step up from Type 1 because their definitions are a
              little more maleable, but still, they shouldn't be available in the HTML because they
              are presentational. In HTML, you should use semantic classnames.
          section
            h4 Type 3 Utility: Classnames that describe their function
            p.
              &ldquo;Semantic&rdquo; classnames aren't really semantic (they don't actually *convey*
              meaning to the HTML or UAs (user agents)). Rather, they are *named* semantically
              because they describe the meaning of the component and/or its contents. Examples
              include `.pacingtable`, `.answer`, `.optional`, `.menu`, and `.success`.
            p.
              These are good classes to use in HTML because they mark up elements with data describing
              what they mean. For example, take the element `p.success`. There are two semantic
              things going on here: first, the `p` tag describes what the eachlement *is*, but
              second, the `class="success"` attribute describes what the element *means*: it's some
              sort of indication of success, such as the completion of an upload. Of course, only the
              first of these is actually meaningful to a UA, but that is not to say that the classname
              doesn't add any semantic value for the benefit of human developers. The bottom line,
              semantic classnames *should* be accessible to the HTML.
          section
            h4 Type 4 Utility: classes used to add semantic value to the HTML
            p.
              A common use of classes to extend HTML would be to create elements that aren't present
              in the HTML standard. Based on an author's field, the HTML specification may or may not
              have an adequate sampling of types of elements for the author's work. For example, why
              is there not an `abstract` element? I suppose the solution would be to use
              `p class="abstract"`. This is an example of using a classname to "extend" the `p`
              element: it is a type of paragraph, namely an article abstract.
            p.
              The biggest use of Type 4 classes I can think of would be
              [Microformats](http://microformats.org/). However this is basically an industry
              standard, albeit easily extendable, and individual developers can't use their own
              custom classes for this. As stated at the top of this page, classes are really meant to
              add styles and that's about it. They should not indicate semantics to user agents
              in my opinion. To add semantic value, I would recommend using another method such as the
              custom `data-*` HTML attribute, [Microdata](http://schema.org/)
              (`itemscope` and `itemprop`), and/or [ARIA roles].
