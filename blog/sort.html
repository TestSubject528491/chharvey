<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Sorting Algorithms</title>
<meta charset="UTF-8"/>
<meta name="author" content="Christopher H. Harvey"/>
<meta name="description" content="A comparison of the most popular comparison sorting algorithms used in computer science."/>
<link rel="stylesheet" href="../core/styles/all.css"/>
<style>
</style>
<script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,http://chharvey.github.io/hosting/mathjax-localconfig.js"></script>
<script src="../core/scripts/global.js"></script>
<script src="sort.js"></script>
</head>
<body>
<main class="Article" data-status="draft">
<header>
  <h1 class="H Alp">Comparison Sorting Algorithms</h1>
	<dl class="Docmeta">
		<dt>Author</dt>
		<dd>Christopher H. Harvey</dd>
		<dt>Description</dt>
		<dd>A comparison of the most popular comparison sorting algorithms used in computer science.</dd>
		<!-- <dt>Completed</dt> -->
		<!-- <dt>Released</dt> -->
		<dt>Updated</dt>
		<dd class="update recent"><time datetime="2014-10-16 21:14">Oct 16, 2014 <span class="hm">21:14 PM</span></time></dd>
		<dt>Tags</dt>
		<dd>computer science</dd>
		<dd>sorting</dd>
	</dl>
</header>
<p class="P Intro">This article describes and makes comparisons among the Comparison Sorting Algorithms.</p>
<p class="P">A sorting algorithm takes an unordered list of objects and arranges them according to
  a few axioms of total order. The total ordering relation will be named, for simplicity,
  <i>less-than</i>. The axioms are explained below:</p>
<ul class="Olist">
  <li class="Item">
    <span class="Lede">Reflexivity</span>
    Any element is <i>less-than</i> itself.
    <p class="Fig"><span class="M">x\le x</span></p>
  </li>
  <li class="Item">
    <span class="Lede">Antisymmetry</span>
    Any two elements that are <i>less-than</i> each other are equal.
    <p class="Fig">if <span class="M">x\le y</span> and <span class="M">y\le x</span> then
      <span class="M">x=y</span></span></p>
  </li>
  <li class="Item">
    <span class="Lede">Transitivity</span>
    The <i>less-than</i> relation carries over.
    <p class="Fig">if <span class="M">x\le y</span> and <span class="M">y\le z</span> then
      <span class="M">x\le z</span></p>
  </li>
  <li class="Item">
    <span class="Lede">Totality</span>
    Any two elements can be compared to each other.
    <p class="Fig"><span class="M">x\le y</span> or <span class="M">y\le x</span> (or possibly both)</p>
  </li>
</ul>
<p class="P">It is fortunate that these axioms are satisfied by the JavaScript relation
  <code>&lt;=</code> on the positive integers.</p>
<p class="P">In addition to the axioms of total order, we are assuming the set has a finite number
  of elements. It is then a consequence that there be a minimum and a maximum in the set.</p>
<ul class="Ulist">
  <li class="Item">
    A <dfn id="d-minimum">minimal element</dfn>, or minimum, in a set is an element that is
    <i>less-than</i> every element in the set.
    <p class="Fig">there exists an element <span class="M">a</span> in the set such that
      for every <span class="M">x</span> in the set, <span class="M">a \le x</span></p>
  </li>
  <li class="Item">
    A <dfn id="d-maximum">maximal element</dfn>, or maximum, in a set is an element for which every
    element is <i>less-than</i> that element.
    <p class="Fig">there exists an element <span class="M">b</span> in the set such that
      for every <span class="M">x</span> in the set, <span class="M">x \le b</span></p>
  </li>
</ul>
<p class="P">A comparison sorting algorithm sorts a set only by comparing elements in the set,
  as opposed to other sorting algorithms that use other methods... In this article we assume the
  goal is to sort a finite set of positive integers from least to greatest.</p>
<section id="simple">
	<h1 class="H Bet">Simple Sorts</h1>
	<section>
		<h1 class="H Gam">Selection Sort</h1>
    <p class="P">A <dfn id="d-selection">selection sort</dfn> finds the minimum in the set of all data,
      and then swaps that minimum with the first element. It then repeats this process with the
      remaining data.</p>
    <code class="Codeblock">function selectSort(dataset) {
  for (var i = 0; i < dataset.length; i++) {
    var subarray = subarray(dataset, i, dataset.length - 1);
    var min = findmin(subarray);
    swap(dataset[i], min);
  }
  return dataset;
}</code>
    <p class="P">A selection sort has the advantage of executing a maximum of <var>n</var> swaps.
      Because there is onl one loop loop It </p>
	</section>
	<section>
		<h1 class="H Gam">Insertion Sort</h1>
		<!-- <p>An <dfn id="d-insertion">insertion sort</dfn> creates an empty copy of the given array</p> -->
		<h2></h2>
	</section>
</section>
<section id="efficient">
	<h1 class="H Bet">Efficient Sorts</h1>
	<section>
		<h1 class="H">Mergesort</h1>
	</section>
	<section>
		<h1 class="H">Heapsort</h1>
	</section>
	<section>
		<h1 class="H">Quicksort</h1>
	</section>
</section>
<section id="bubble-type">
	<h1 class="H Bet">Bubble-type Sorts</h1>
	<section>
		<h1 class="H">Bubble Sort</h1>
	</section>
	<section>
		<h1 class="H">Shell Sort</h1>
	</section>
	<section>
		<h1 class="H">Comb Sort</h1>
	</section>
</section>
<table class="Table">
	<caption class="Capt">comparison of Comparison Sorts</caption>
	<thead class="Rowgroup Head">
		<tr class="Row">
			<th class="Cell Hc">Name</th>
			<th class="Cell Hc">Runtime Range</th>
			<th class="Cell Hc">Swaps Range</th>
		</tr>
	</thead>
	<tbody class="Rowgroup Body">
		<tr class="Row">
			<th class="Cell Hc">Selection</th>
			<td class="Cell">O(n^2)</td>
			<td class="Cell">0&ndash;O(n)</td>
		</tr>
		<tr class="Row">
			<th class="Cell Hc">Insertion</th>
			<td class="Cell">O(n)&ndash;O(n^2)</td>
			<td class="Cell">O(n)</td>
		</tr>
	</tbody>
</table>

</main>
</body>
</html>
