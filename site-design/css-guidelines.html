<!--
---
---
-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CSS Formatting Guidelines</title>
<meta charset="UTF-8"/>
<meta name="author" content="Christopher H. Harvey"/>
<meta name="description" content="Guidelines on how to format text in CSS and Less files."/>
<!--<link rel="stylesheet" href="../core/styles/all.css"/>-->
<style>
	.code--block {white-space: pre-wrap;}
	[data-status="draft"] {
		background-color: #fffcfa;
		opacity: 0.618;
	}
</style>
<!--{% include all-js.html %}-->
</head>
<body>
<main>
<h1 class="h--alpha">CSS Formatting Guidelines</h1>
<p class="prose">This document describes formatting guidelines for <a href="http://www.w3.org/TR/CSS/" rel="external">Cascading Style Sheets</a> and <a href="http://lesscss.org" rel="external">Less Style Sheets</a>.</p>
<section id="cascade">
	<h1 class="h--beta">Honor the Cascade</h1>
	<p>The &ldquo;C&rdquo; in CSS stands for &ldquo;Cascading.&rdquo; There are two aspects of the way that stylesheets Cascade: one, and most obviously, some properties of elements are inherited from their parent elements (&ldquo;parent&rdquo; here referring to the container in the DOM tree). These properties trickle down the tree, getting applied to each child unless it is overriden by that child's property. This has nothing to do with specificity; this has only to do with the fact that elements' properties override the inherited properties of their parents.</p>
	<p>The second aspect of the Cascade is where the true beauty of CSS can be appreciated. In terms of <a>selector specificity</a>, more specific properties override less specific ones. This means that the least specific properties (those that apply to element selectors) get applied first, followed by class selectors, followed by combinator selectors, and so on. The order these selectors are defined doesn't matter: their specificity will take precidence. However, in the case that two selectors have the same specificity, the styles will cascade from top to bottom in the CSS file, so the latter selector's property will override the former's. It is for this reason that we want to define our properties, selectors, and stylsheets in order of increasing specificity.</p>
	<section id="property-order">
		<h1 class="h--gamma">Property Order</h1>
		<p class="prose">Within a block, the properties must be written in order of decreasing structure definition. See the figure below for an illustration.</p>
		<figure class="Fig">
			<figcaption class="Capt Before">This inverted pyramid illustrates how CSS properties are related.</figcaption>
			<svg xmlns="http://www.w3.org/2000/svg" width="600" height="260">
				<style scoped="">
					line {
						stroke-width: 2px;
					}
					text {
						font-size: 11pt;
						font-family: sans-serif;
					}
					.tier1 {
						fill: #0270bb;
						stroke: #0270bb;
					}
					.tier2 {
						fill: #2ba8e0;
						stroke: #2ba8e0;
					}
					.tier3 {
						fill: #54e0ff;
						stroke: #54e0ff;
					}
					.category {
						font-weight: bold;
						fill: #fff;
					}
				</style>
				<polygon class="tier1" points="0,0
				                               300,0
				                               150,260"/>
				<polygon class="tier2" points="50,87
				                               250, 87
				                               150, 260"/>
				<polygon class="tier3" points="100,173
				                               200,173
				                               150,260"/>
				<line class="tier1" x1="150" y1="50"  x2="600" y2="50"/>
				<line class="tier2" x1="150" y1="135" x2="600" y2="135"/>
				<line class="tier3" x1="150" y1="220" x2="600" y2="220"/>
				<text class="category" x="110" y="20">Structural</text>
				<text class="category" x="120" y="105">Textual</text>
				<text class="category" x="112" y="190">Schematic</text>
				<text x="300" y="45">display, box model, position, transform</text>
				<text x="300" y="130">content, font, text, decoration</text>
				<text x="300" y="215">color, background, visibility</text>
			</svg>
			<p class="P">Authors are encouraged to define properties in order shown from top to bottom in the pyramid. The top base of the pyramid contains properties that set up foundation and structure, such as display and position. The middle contains font and text properties. Notice how <a>container is defined before content</a>. Then we finish with low-level schematic (&ldquo;scheme-like&rdquo;) properties, such as color, at the vertex on the bottom.</p>
		</figure>

		<p class="P">The properties and declarations within a block must appear in the following order. <span class="success">Note: This list applies to the Less language as well.</span></p>
		<ol class="list--outline">
			<li><span class="lede-sent">Extensions</span> An <a>extension</a> is a directive that indicates this <del datetime="2014-05-02T02:52">class is a subclass of a parent class</del> <ins datetime="2014-05-02T02:52">block shares common properties with another block</ins>. If multiple extensions are present, they must appear in the order they are defined in the stylesheet. This block must only use <code>:extend()</code> on blocks that have been previously defined.</li>
			<li><span class="lede-sent">Class Includes</span> Included blocks must appear in the order they are defined in the stylesheet. This block must only include blocks that have been previously defined.</li>
			<li><span class="lede-sent">Mixin Includes</span> Mixins must appear in the order they are defined in the stylesheet. This block must only include mixins that have been previously defined.</li>
			<li><span class="lede-sent">Properties</span> After extensions and includes are set, CSS properties must appear in the following order.
				<ol>
					<li>Structural:
						<ol>
							<li>display</li>
							<li>width</li>
							<li>height</li>
							<li>padding (-top, -right, -bottom, -left)</li>
							<li>border (-top, -right, -bottom, -left) (-width, -style, -color, -radius)</li>
							<li>outline</li>
							<li>box-shadow</li>
							<li>margin (-top, -right, -bottom, -left)</li>
							<li>position</li>
							<li>z-index</li>
							<li>transformations</li>
						</ol>
					</li>
					<li>Textual:
						<ol>
							<li>content and counter</li>
							<li>font (-style, -variant, -weight, -size, -family)</li>
							<li>letter-spacing</li>
							<li>line-height</li>
							<li>text-align</li>
							<li>text-indent</li>
							<li>text-transform</li>
							<li>text-decoration</li>
							<li>text-shadow</li>
							<li>white-space</li>
							<li>list-style (-type, -position, -image)</li>
						</ol>
					</li>
					<li>Schematic:
						<ol>
							<li>color</li>
							<li>background-color</li>
							<li>background-image</li>
							<li>background-size</li>
							<li>background-position</li>
							<li>background-repeat</li>
							<li>background-attachment</li>
							<li>background-origin</li>
							<li>opacity</li>
							<li>visibility</li>
							<li>cursor</li>
						</ol>
					</li>
				</ol>
			</li>
			<li><span class="lede-sent">Qualifiers</span> After the properties of this selector have been set, define properties of qualifying sub-selectors in the following order.
				<ol>
					<li>Classes (<code>&amp;.mod {}</code>)</li>
					<li>Pseudo-classes (<code>&amp;:hover {}</code>)</li>
					<li>Attributes (<code>&amp;[rel~=&quot;external&quot;] {}</code>)</li>
					<li>Pseudo-elements (<code>&amp;::before {}</code>)</li>
				</ol>
			</li>
			<li><span class="lede-sent">Combinators</span> The order of the combinator selectors is <a href="#selector-order">chosen specifically</a> so.
				<ol>
					<li>general descendant selectors <code>&amp; .des {}</code></li>
					<li>child selectors <code>&amp; &gt; .child {}</code></li>
					<li>general sibling selectors <code>&amp; ~ .sib {}</code></li>
					<li>adjacent sibling selectors <code>&amp; + .firstsib {}</code></li>
				</ol>
			</li>
		</ol>
	</section>
	<section id="selector-order">
		<h1 class="h--gamma">Selector Order</h1>
		<p class="prose">In general, selectors within a group of style blocks should be written in order of increasing specificity. This means elements first, then classes, then qualifiers/modifiers (pseudo-), and combinators last. The order of qualifiers is not too important, but the order of combinators is. This is because multiple selectors may have the same specificity when an author's belief might be that they do not.</p>
### A note about selector order:

    <style>
    .foo + .bar {color: red;}  /* if .bar immediately follows .foo, it is colored red */
    .foo ~ .bar {color: blue;} /* all .bar following .foo are colored blue */
    </style>
    <div class="foo"> Exercise: </div>
    <div class="bar"> What color is this? Hint: it's not red.</div>

The adjacent sibling of an element *is* a general sibling, but it is a &ldquo;specific&rdquo; type of sibling, namely, an adjacent one. Therefore it's a common misconception that the selector `.foo + .bar {}` has a higher **specificity** than `.foo ~ .bar {}`, and thus the former will override the latter (regardless of the order in which they are defined). After all, wouldn't you think that a `.foo + .bar {}` is a special case of `.foo ~ .bar {}`? Actually, these two selectors actually have equivalent **specificity**, so whichever one is written last in the stylesheet will take precedence. The `div.bar` in the exercise above is blue.

The bottom line is that authors must define `.foo ~ .bar {}` *before* `.foo + .bar {}` in the stylesheet in order to get the results they expect. The same method applies to `.baz .qux {}` and `.baz > .qux {}`: the former must be defined before the latter because the latter is a special case of the former, even though they have the same specificity.
	</section>
</section>
<section id="classname-syntax" data-status="draft">
	<h1 class="h--beta">Classname Syntax</h1>
	<p class="prose">Each selector has a <a>specificity</a> and an <a>efficiency</a>. I won't talk about them too much here, but generally the more efficient a selector is, the more specific it gets, and vice versa: less specific selectors are usually not that efficient. Our goal is to find the right balance between keeping our selectors low in specificity while high in efficiency.</p>
	<p class="prose">The majority of the selectors in a stylesheet should be single classes only. Class selectors are the most efficient way for browsers to style pages, <a>not counting IDs</a>. For the most part, <strong>use single class selectors</strong>.</p>
	<p class="prose"><span class="lede-sent">Content before presentation.</span> There are exceptions to the &ldquo;single-class&rdquo; rule. When it comes down to efficient HTML versus efficient CSS, HTML wins. The reason? Semantics always trumps style. You've got a problem when you find yourself having to adjust a huge amount of HTML just to conform to CSS best practices (such as adding 8 different classes to an element to get it to look exactly how you want). It should be the other way around. CSS should conform to how HTML is (or should be) written, even if it means sacrificing a little bit of efficiency.</p>
	<p class="prose">Classnames must consist of uppercase and lowercase letters of the English alphabet (<a href="http://www.fileformat.info/info/unicode/char/0041/index.htm" rel="external"><code>U+0041</code></a>&ndash;<a href="http://www.fileformat.info/info/unicode/char/005a/index.htm" rel="external"><code>U+005A</code></a>, <a href="http://www.fileformat.info/info/unicode/char/0061/index.htm" rel="external"><code>U+0061</code></a>&ndash;<a href="http://www.fileformat.info/info/unicode/char/007a/index.htm" rel="external"><code>U+007A</code></a>), hyphens (<code>-</code> <a href="http://www.fileformat.info/info/unicode/char/002d/index.htm" rel="external"><code>U+002D</code></a>), or underscores (<code>_</code> <a href="http://www.fileformat.info/info/unicode/char/005f/index.htm" rel="external"><code>U+005F</code></a>).</p>
	<p class="prose">Major words in a classname must appear in order from general to specific, and separated by one hyphen. Minor words should be combined, not separated. &ldquo;Major&rdquo; and &ldquo;minor&rdquo; are not standardized; they are left to the author's discretion. Examples:</p>
	<ul>
		<li><code>.lede-para</code></li>
		<li><code>.lede-sent</code></li>
		<li><code>.dropcap</code></li>
		<li><code>.rowgroup</code></li>
	</ul>
	<section id="namespace">
		<h1 class="h--gamma">Namespace Prefixes</h1>
		<p class="prose">Classnames used only on one page or in a group of pages (e.g., a sub-site) must begin with a namespace prefix. This will help keep styles separated and prevent overuse of classnames. The namespace must contain only lowercase letters and should be less than 6 characters. The namespace must be followed by an underscore.</p>
		<ul>
			<li><code>.res_skillgroup</code></li>
			<li><code>.scheme_colortable</code></li>
			<li><code>.grid_phidemo</code></li>
		</ul>
		<p class="prose">Chances are, you will need to add classes to your HTML elements so JavaScript can grab them and do things to them. We call these classes <dfn>JS hooks</dfn>. <strong>Never use CSS styling classes for JS hooks.</strong> Use the <code>.js_</code> namespace prefix, and don't apply any styles to these classes.</p>
		<ul>
			<li><code>.js_table</code></li>
			<li><code>.js_expando</code></li>
		</ul>
	</section>
	<section id="subclasses">
		<h1 class="h--gamma">Subclasses</h1>
		<p class="prose">Some classes will need modifiers for sizing, etc. In the name of object-oriented programming, let's call these classes &ldquo;extensions.&rdquo; For instance, let's say you want to have a class <code>.foo</code> that extends a class <code>.bar</code>. That is, <code>.foo</code> has all the properties that <code>.bar</code> has, and possibly then some. Use a double-hyphen to separate a classname with its modifier. Our extension would then be called <code>.bar--foo</code>. If a classname such as <code class="lang-css">.bar--foo</code> exists, it is assumed that a classname <code class="lang-css">.bar</code> exists, which is the parent class. Classes may have nested extensions, that is, extensions of extensions. In object-oriented language, these would be called class descendants.</p>
		<ul>
			<li><code>.box--inline</code></li>
			<li><code>.h--alpha</code></li>
			<li><code>.list--bare</code></li>
			<li><code>.list--inline--c</code></li>
			<li><code>.dl--table--sml</code></li>
		</ul>
	</section>
	<section id="descendants">
		<h1 class="h--gamma">Descendants</h1>
		<p class="prose draft"><em>Class</em> inheritance/descendants are different than <em>object</em> inheritance/descendants. A class child, or an extension, of a class is a class that inherits all the properties of its parent. On the other hand, a component child of an object is literally an object within an object (for example, a <code>p</code> within a <code>section</code>). Some properties such as <code>color</code> and <code>font-weight</code> are inherited through object inheritance, but other properties such as <code>border</code> are not.</p>
		<p class="prose">With <a href="#descendant-selectors">some exceptions</a>, descendant selectors are usually avoided, so indicating that one class of HTML element belongs as a descendent of another class of element is <a>not specified via selector</a>: it is usually specified in some sort of documentation. However it is advantageous to additionaly <strong>indicate so in the classname</strong> for extra unambiguity, without sacrificing specificity or efficiency. This way, the developer knows that the element belongs inside the other by inspection.</p>
		<p class="prose">In the name of a class that is a descendant of another class, the &ldquo;parent classname&rdquo; and &ldquo;child classname&rdquo; are separated by two underscores. This similar to the practice of using one underscore to indicate namespaces. (In a way, the child classname is in the parent classname namespace.) If a child classname such as <code>.bar__foo</code> exists, it is assumed that a classname <code>.bar</code> exists.</p>
		<ul>
			<li><code>.bc__anc</code></li>
			<li><code>.fnotes__fn</code></li>
			<li><code>.lang--html__tag</code></li>
			<li><code>.res_skilldetail__job</code></li>
		</ul>
		<p class="prose"><a href="#subcomponents">As stated above</a>, it is best practice to avoid child selectors (<code>.parent &gt; .child</code>) and descendant selectors (<code>.ancestor .descendant</code>). However there are some cases in which this is okay, and these cases involve intrinsic ownership: elements that belong to other elements by HTML standards.</p>
		<p>Another case in which this is okay: subcomponents. Even if not by HTML standards, if a class <code>.Wheel</code> belongs to (is a child of) class <code>.Car</code>, it would be okay to have the selector <code>.Car &gt; .Wheel</code></p>



		<section id="lists">
			<h1 class="h--delta">Lists</h1>
			<p class="prose">The following CSS is <em>very</em> efficient and not very specific at all. This is normally very good coding:</p>
			<code class="code--block">
<span class="code__sel">.nav {<span class="code__prop">&hellip;</span>}</span>
<span class="code__sel">.nav__link {<span class="code__prop">&hellip;</span>}</span>
			</code>
			<code class="code--block">
<span class="code__tag">&lt;ol <span class="code__attr">class=&quot;<span class="code__val">nav</span>&quot;</span>&gt;</span>
	<span class="code__tag">&lt;li <span class="code__attr">class=&quot;<span class="code__val">nav__link</span>&quot;</span>&gt;</span><span class="code__tag">&lt;a&gt;</span>link 1<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
	<span class="code__tag">&lt;li <span class="code__attr">class=&quot;<span class="code__val">nav__link</span>&quot;</span>&gt;</span><span class="code__tag">&lt;a&gt;</span>link 2<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
<span class="code__tag">&lt;/ol&gt;</span>
			</code>
			<p class="prose">While this is usually best practice, the issue here is that each list item requires the class <code>.nav__link</code>, and that every time an item gets added to the list, the class has to be added again. While this may be efficient CSS, this is very <em>inefficient</em> HTML and it's not very <abbr title="don't repeat yourself">DRY</abbr>. For instance, if the list item classname were to change in the <a>Theoretical Redesign Future&trade;</a>, we would have to go back and change all the classes on each list item in the HTML.</p>
			<p class="prose">In this case it is better to view the list as one component, with the list items as subcomponents of that component. Here we are using a class selector to target the <code>ol</code>, but we are permitted to use an element selector to target the <code>li</code>s inside. Yes, the selector <code>.nav &gt; li</code> is more specific than <code>.nav__link</code>, but that is a small price to pay for more efficient HTML.</p>
			<code class="code--block">
<span class="code__sel">.nav {<span class="code__prop">&hellip;</span>}</span>
<span class="code__sel">nav &gt; li {<span class="code__prop">&hellip;</span>}</span>
			</code>
			<code class="code--block">
<span class="code__tag">&lt;ol <span class="code__attr">class=&quot;<span class="code__val">nav</span>&quot;</span>&gt;</span>
	<span class="code__tag">&lt;li&gt;</span><span class="code__tag">&lt;a&gt;</span>link 1<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
	<span class="code__tag">&lt;li&gt;</span><span class="code__tag">&lt;a&gt;</span>link 2<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
<span class="code__tag">&lt;/ol&gt;</span>
			</code>
		</section>
		<section id="tables">
			<h1 class="h--delta">Tables</h1>
			<p class="prose">I'm not going to give any examples here, but selectors describing any <code>thead</code>, <code>tbody</code>, <code>tfoot</code>, <code>tr</code>, <code>th</code>, or <code>td</code> elements, etc. inside any <code>table</code> elements are acceptable exceptions to the &ldquo;single-class&rdquo; rule.</p>
		</section>
		<section>
			<h1 class="h--delta">Miscellaneous Groupings</h1>
			<ul>
				<li><code>h1 &gt; .h__sub</code>, etc. a subheading element within a heading 1 (as opposed to a heading 2, etc.). Otherwise we would need <code>.h1__sub</code> through <code>.h6__sub</code>.</li>
				<li><code>.fn a</code>, a link inside a footnote superscript</li>
				<li><code>blockquote &gt; cite</code>, a citation inside a blockquote</li>
			</ul>
		</section>
	</section>
</section>
</main>
</body>
</html>
