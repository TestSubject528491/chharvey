<!--
---
---
-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CSS Formatting Guidelines</title>
<meta charset="UTF-8"/>
<meta name="author" content="Christopher H. Harvey"/>
<meta name="description" content="Guidelines on how to format text in CSS and Less files."/>
<!--<link rel="stylesheet" href="../core/styles/all.css"/>-->
<style>
	.code--block {white-space: pre-wrap;}
	[data-status="draft"] {
		background-color: #fffcfa;
		opacity: 0.618;
	}
</style>
<!--{% include all-js.html %}-->
</head>
<body>
<main>
<h1 class="h--alpha">CSS Formatting Guidelines</h1>
<section id="cascade">
	<h1 class="h--beta">Honor the Cascade</h1>
	<section id="property-order">
		<h1 class="h--gamma">Property Order</h1>
		<p class="P">The properties and declarations within a block must appear in the following order. <span class="success">Note: This list applies to the Less language as well.</span></p>
		<ol class="list--outline">
			<li><span class="lede-sent">Extensions</span> An <a>extension</a> is a directive that indicates this <del datetime="2014-05-02T02:52">class is a subclass of a parent class</del> <ins datetime="2014-05-02T02:52">block shares common properties with another block</ins>. If multiple extensions are present, they must appear in the order they are defined in the stylesheet. This block must only use <code>:extend()</code> on blocks that have been previously defined.</li>
			<li><span class="lede-sent">Class Includes</span> Included blocks must appear in the order they are defined in the stylesheet. This block must only include blocks that have been previously defined.</li>
			<li><span class="lede-sent">Mixin Includes</span> Mixins must appear in the order they are defined in the stylesheet. This block must only include mixins that have been previously defined.</li>
			<li><span class="lede-sent">Properties</span> After extensions and includes are set, CSS properties must appear in the following order.
			</li>
			<li><span class="lede-sent">Qualifiers</span> After the properties of this selector have been set, define properties of qualifying sub-selectors in the following order.
				<ol>
					<li>Classes (<code>&amp;.mod {}</code>)</li>
					<li>Pseudo-classes (<code>&amp;:hover {}</code>)</li>
					<li>Attributes (<code>&amp;[rel~=&quot;external&quot;] {}</code>)</li>
					<li>Pseudo-elements (<code>&amp;::before {}</code>)</li>
				</ol>
			</li>
			<li><span class="lede-sent">Combinators</span> The order of the combinator selectors is <a href="#selector-order">chosen specifically</a> so.
				<ol>
					<li>general descendant selectors <code>&amp; .des {}</code></li>
					<li>child selectors <code>&amp; &gt; .child {}</code></li>
					<li>general sibling selectors <code>&amp; ~ .sib {}</code></li>
					<li>adjacent sibling selectors <code>&amp; + .firstsib {}</code></li>
				</ol>
			</li>
		</ol>
	</section>
</section>
<section id="classname-syntax" data-status="draft">
	<h1 class="h--beta">Classname Syntax</h1>
	<p class="prose">Each selector has a <a>specificity</a> and an <a>efficiency</a>. I won't talk about them too much here, but generally the more efficient a selector is, the more specific it gets, and vice versa: less specific selectors are usually not that efficient. Our goal is to find the right balance between keeping our selectors low in specificity while high in efficiency.</p>
	<p class="prose">The majority of the selectors in a stylesheet should be single classes only. Class selectors are the most efficient way for browsers to style pages, <a>not counting IDs</a>. For the most part, <strong>use single class selectors</strong>.</p>
	<p class="prose"><span class="lede-sent">Content before presentation.</span> There are exceptions to the &ldquo;single-class&rdquo; rule. When it comes down to efficient HTML versus efficient CSS, HTML wins. The reason? Semantics always trumps style. You've got a problem when you find yourself having to adjust a huge amount of HTML just to conform to CSS best practices (such as adding 8 different classes to an element to get it to look exactly how you want). It should be the other way around. CSS should conform to how HTML is (or should be) written, even if it means sacrificing a little bit of efficiency.</p>
	<p class="prose">Classnames must consist of uppercase and lowercase letters of the English alphabet (<a href="http://www.fileformat.info/info/unicode/char/0041/index.htm" rel="external"><code>U+0041</code></a>&ndash;<a href="http://www.fileformat.info/info/unicode/char/005a/index.htm" rel="external"><code>U+005A</code></a>, <a href="http://www.fileformat.info/info/unicode/char/0061/index.htm" rel="external"><code>U+0061</code></a>&ndash;<a href="http://www.fileformat.info/info/unicode/char/007a/index.htm" rel="external"><code>U+007A</code></a>), hyphens (<code>-</code> <a href="http://www.fileformat.info/info/unicode/char/002d/index.htm" rel="external"><code>U+002D</code></a>), or underscores (<code>_</code> <a href="http://www.fileformat.info/info/unicode/char/005f/index.htm" rel="external"><code>U+005F</code></a>).</p>
	<p class="prose">Major words in a classname must appear in order from general to specific, and separated by one hyphen. Minor words should be combined, not separated. &ldquo;Major&rdquo; and &ldquo;minor&rdquo; are not standardized; they are left to the author's discretion. Examples:</p>
	<ul>
		<li><code>.lede-para</code></li>
		<li><code>.lede-sent</code></li>
		<li><code>.dropcap</code></li>
		<li><code>.rowgroup</code></li>
	</ul>
	<section id="namespace">
		<h1 class="h--gamma">Namespace Prefixes</h1>
		<p class="prose">Classnames used only on one page or in a group of pages (<i lang="la"><abbr title="exampli gratia">e.g.</abbr></i>, a sub-site) must begin with a namespace prefix. This will help keep styles separated and prevent overuse of classnames. The namespace must contain only lowercase letters and should be less than 6 characters. The namespace must be followed by an underscore.</p>
		<ul>
			<li><code>.res_skillgroup</code></li>
			<li><code>.scheme_colortable</code></li>
			<li><code>.grid_phidemo</code></li>
		</ul>
		<p class="prose">Chances are, you will need to add classes to your HTML elements so JavaScript can grab them and do things to them. We call these classes <dfn>JS hooks</dfn>. <strong>Never use CSS styling classes for JS hooks.</strong> Use the <code>.js_</code> namespace prefix, and don't apply any styles to these classes.</p>
		<ul>
			<li><code>.js_table</code></li>
			<li><code>.js_expando</code></li>
		</ul>
	</section>
	<section id="subclasses">
		<h1 class="h--gamma">Subclasses</h1>
		<p class="prose">Some classes will need modifiers for sizing, <i lang="la"><abbr title="et cetera">etc.</abbr></i> In the name of object-oriented programming, let's call these classes &ldquo;extensions.&rdquo; For instance, let's say you want to have a class <code>.foo</code> that extends a class <code>.bar</code>. That is, <code>.foo</code> has all the properties that <code>.bar</code> has, and possibly then some. Use a double-hyphen to separate a classname with its modifier. Our extension would then be called <code>.bar--foo</code>. If a classname such as <code class="lang-css">.bar--foo</code> exists, it is assumed that a classname <code class="lang-css">.bar</code> exists, which is the parent class. Classes may have nested extensions, that is, extensions of extensions. In object-oriented language, these would be called class descendants.</p>
		<ul>
			<li><code>.box--inline</code></li>
			<li><code>.h--alpha</code></li>
			<li><code>.list--bare</code></li>
			<li><code>.list--inline--c</code></li>
			<li><code>.dl--table--sml</code></li>
		</ul>
	</section>
	<section id="descendants">
		<h1 class="h--gamma">Descendants</h1>
		<p class="prose draft"><em>Class</em> inheritance/descendants are different than <em>object</em> inheritance/descendants. A class child, or an extension, of a class is a class that inherits all the properties of its parent. On the other hand, a component child of an object is literally an object within an object (for example, a <code>p</code> within a <code>section</code>). Some properties such as <code>color</code> and <code>font-weight</code> are inherited through object inheritance, but other properties such as <code>border</code> are not.</p>
		<p class="prose">With <a href="#descendant-selectors">some exceptions</a>, descendant selectors are usually avoided, so indicating that one class of HTML element belongs as a descendent of another class of element is <a>not specified via selector</a>: it is usually specified in some sort of documentation. However it is advantageous to additionaly <strong>indicate so in the classname</strong> for extra unambiguity, without sacrificing specificity or efficiency. This way, the developer knows that the element belongs inside the other by inspection.</p>
		<p class="prose">In the name of a class that is a descendant of another class, the &ldquo;parent classname&rdquo; and &ldquo;child classname&rdquo; are separated by two underscores. This similar to the practice of using one underscore to indicate namespaces. (In a way, the child classname is in the parent classname namespace.) If a child classname such as <code>.bar__foo</code> exists, it is assumed that a classname <code>.bar</code> exists.</p>
		<ul>
			<li><code>.bc__anc</code></li>
			<li><code>.fnotes__fn</code></li>
			<li><code>.lang--html__tag</code></li>
			<li><code>.res_skilldetail__job</code></li>
		</ul>
		<p class="prose"><a href="#subcomponents">As stated above</a>, it is best practice to avoid child selectors (<code>.parent &gt; .child</code>) and descendant selectors (<code>.ancestor .descendant</code>). However there are some cases in which this is okay, and these cases involve intrinsic ownership: elements that belong to other elements by HTML standards.</p>
		<p>Another case in which this is okay: subcomponents. Even if not by HTML standards, if a class <code>.Wheel</code> belongs to (is a child of) class <code>.Car</code>, it would be okay to have the selector <code>.Car &gt; .Wheel</code></p>



		<section id="lists">
			<h1 class="h--delta">Lists</h1>
			<p class="prose">The following CSS is <em>very</em> efficient and not very specific at all. This is normally very good coding:</p>
			<code class="code--block">
<span class="code__sel">.nav {<span class="code__prop">&hellip;</span>}</span>
<span class="code__sel">.nav__link {<span class="code__prop">&hellip;</span>}</span>
			</code>
			<code class="code--block">
<span class="code__tag">&lt;ol <span class="code__attr">class=&quot;<span class="code__val">nav</span>&quot;</span>&gt;</span>
	<span class="code__tag">&lt;li <span class="code__attr">class=&quot;<span class="code__val">nav__link</span>&quot;</span>&gt;</span><span class="code__tag">&lt;a&gt;</span>link 1<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
	<span class="code__tag">&lt;li <span class="code__attr">class=&quot;<span class="code__val">nav__link</span>&quot;</span>&gt;</span><span class="code__tag">&lt;a&gt;</span>link 2<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
<span class="code__tag">&lt;/ol&gt;</span>
			</code>
			<p class="prose">While this is usually best practice, the issue here is that each list item requires the class <code>.nav__link</code>, and that every time an item gets added to the list, the class has to be added again. While this may be efficient CSS, this is very <em>inefficient</em> HTML and it's not very <abbr title="don't repeat yourself">DRY</abbr>. For instance, if the list item classname were to change in the <a>Theoretical Redesign Future&trade;</a>, we would have to go back and change all the classes on each list item in the HTML.</p>
			<p class="prose">In this case it is better to view the list as one component, with the list items as subcomponents of that component. Here we are using a class selector to target the <code>ol</code>, but we are permitted to use an element selector to target the <code>li</code>s inside. Yes, the selector <code>.nav &gt; li</code> is more specific than <code>.nav__link</code>, but that is a small price to pay for more efficient HTML.</p>
			<code class="code--block">
<span class="code__sel">.nav {<span class="code__prop">&hellip;</span>}</span>
<span class="code__sel">nav &gt; li {<span class="code__prop">&hellip;</span>}</span>
			</code>
			<code class="code--block">
<span class="code__tag">&lt;ol <span class="code__attr">class=&quot;<span class="code__val">nav</span>&quot;</span>&gt;</span>
	<span class="code__tag">&lt;li&gt;</span><span class="code__tag">&lt;a&gt;</span>link 1<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
	<span class="code__tag">&lt;li&gt;</span><span class="code__tag">&lt;a&gt;</span>link 2<span class="code__tag">&lt;/a&gt;</span><span class="code__tag">&lt;/li&gt;</span>
<span class="code__tag">&lt;/ol&gt;</span>
			</code>
		</section>
		<section id="tables">
			<h1 class="h--delta">Tables</h1>
			<p class="prose">I'm not going to give any examples here, but selectors describing any <code>thead</code>, <code>tbody</code>, <code>tfoot</code>, <code>tr</code>, <code>th</code>, or <code>td</code> elements, <i lang="la"><abbr title="et cetera">etc.</abbr></i> inside any <code>table</code> elements are acceptable exceptions to the &ldquo;single-class&rdquo; rule.</p>
		</section>
		<section>
			<h1 class="h--delta">Miscellaneous Groupings</h1>
			<ul>
				<li><code>h1 &gt; .h__sub</code>, <i lang="la"><abbr title="et cetera">etc.</abbr></i> a subheading element within a heading 1 (as opposed to a heading 2, <i lang="la"><abbr title="et cetera">etc.</abbr></i>). Otherwise we would need <code>.h1__sub</code> through <code>.h6__sub</code>.</li>
				<li><code>.fn a</code>, a link inside a footnote superscript</li>
				<li><code>blockquote &gt; cite</code>, a citation inside a blockquote</li>
			</ul>
		</section>
	</section>
</section>
</main>
</body>
</html>
